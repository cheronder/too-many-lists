# 所有权初探

> 原文链接：[first-ownership.md](https://github.com/rust-unofficial/too-many-lists/blob/master/src/first-ownership.md) <br>
> 翻译基准：[commit b57202a](https://github.com/rust-unofficial/too-many-lists/blob/b57202a5e01b50e4217b85af3d89f49f612dcbae/src/first-ownership.md)

现在可以开始构造我们的链表了。我们将使用普通的（非静态的）方法来与它打交道。在 Rust 中，方法就是一类特殊的函数。它们拥有无须指明类型的 `self` 参数。

```rust, ignore
fn foo(self, arg2: Type2) -> ReturnType {
    // 函数体
}
```

`self` 参数主要有三种形式：`self`、`&mut self`、`&self`。它们分别代表了 Rust 中主要的三种所有权：

* `self` ——值（value）
* `&mut self` ——可变引用（mutable reference）
* `&self` ——共享引用（shared reference）

值意味着**真正的**所有权。你可以对它做任何事情：移动它、销毁它、改变它，或者以引用的方式借出它。当你按值传递对象时，它会被**移动**到新的变量。即新变量拥有了对象的所有权，而原变量就无法访问它了。基于此，大部分方法都不会用 `self` 的形式——谁也不想使用这种会不翼而飞的链表[^1]。

可变引用意味着对你不拥有的对象暂时有**独占**的访问权利。只要有了可变引用，那你就可以做想做的任何事情。当然你得保证当一切都完成之后，它仍处于合法状态（不然就太不尊重它实际的所有者了）。也就是说，你完全可以覆盖掉原来的内容。不过还是有一个特例：在**替换**（*swap*）变量中的内容时，如果没有替代之物（replacement），则千万不能把 `&mut` 中的内容移走。这一点我们之后会经常见到。总之，如果想让方法中的 `self` 是可变的，就可以用 `&mut self` 的形式。

共享引用意味着对你不拥有的对象暂时有**共享**的访问权利。由于访问权利是共享的，所以你基本上不能改变任何东西。打个比方，变量前面的 `&` 就好像把它陈列在博物馆里一样。如果只想观察 `self` 中的内容，用 `&` 形式的方法就可以。

稍后我们会看到，在特定情况下，上述几个关于可变性的规则是可以被规避掉的。这也是共享引用不叫**不可变引用**的缘由。诚然，可变引用也可以称作**独占引用**，但我们会发现在 99% 的情况下，把所有权视作可变性都能提供正确的思路。

[^1]: 调用方法时，会经过把自身传给 `self` 形参的步骤。如果用了按值传递，那么就是移动语义。那么调用者就会失去原有内容的所有权，变成空壳。
